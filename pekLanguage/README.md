# Transpilador

Esse projeto tem como principal intuito o aprendizado, mas para ser bem sincero foi bem divertido üòù

### Mas o que seria um transpilador? E qual a diferen√ßa de um compilador? ü§î

Sendo bem objetivo, o compilador √© receptor do c√≥digo fonte (c√≥digo que voc√™ escreve), e como sa√≠da, produz c√≥digo em linguagem de baixo n√≠vel (mais pr√≥ximo do c√≥digo de m√°quina).

J√° um transpilador tamb√©m √© um receptor do c√≥digo fonte, por√©m produzindo em outra linguagem n√≠vel bem semelhante.

Exemplo: _Typescript_ -> _JavaScript_

sendo o TypeScript o c√≥digo fonte(c√≥digo que escrevemos e temos as suas exceptions de tipagem), e o JavaScript como o c√≥digo gerado e executado.

## Sobre o meu projeto

Em particular, eu fiz indo para o lado do transpilador. Por√©m podemos dizer que os processos s√£o bem semelhantes. A an√°lise l√©xica e sint√°tica e a AST s√£o importantes para ambos.

N√£o √© atoa que chamamos o transpilador de 'source-to-source compiler'.

Ou seja, um compilador que o c√≥digo fonte X gera c√≥digo fonte Y para ser executado. üí°

E entender tanto na parte te√≥rica e pr√°tica como funciona em partes a an√°lise l√©xica, sint√°tica e a produ√ß√£o da AST (_Abstract syntax tree_), foi um processo trabalhoso, divertido e de muito aprendizado.

## Motiva√ß√£o üöÄ

O que me fez construir esse transpilador, al√©m do aprendizado e da experi√™ncia, foi uma rinha de compiladores que aconteceu h√° alguns meses, por√©m ao ver o reposit√≥rio no GitHub, eles j√° deixaram pronto a AST, sendo somente necess√°rio o seu interpretador do arquivo JSON gerado pela AST.

Mas eu queria realmente entender desde a base, como funciona a teoria da linguagem, como a AST √© constru√≠da e posteriormente interpretada.

No meu projeto, eu constru√≠ minha pr√≥pria AST.

Por√©m ao inv√©s de criar um Arquivo JSON com todas as informa√ß√µes dos comandos e posteriormente criar meu interpretador, eu gerei diretamente um arquivo JavaScript, sem a necessidade de criar o meu interpretador. Ou seja, foi em um caminho inverso da Rinha.

O transpilador gera c√≥digo JavaScript (pode ser qualquer outra linguagem que eu queira) baseado na minha AST, talvez um dia se eu quiser mexer no interpretador com uma AST constru√≠da, eu entre no reposit√≥rio da rinha.

## Conhecimentos pr√©vios üìö

- Node.js
- JavaScript
- Programa√ß√£o orientada a objetos
- Gram√°tica (L√©xica, sint√°tica e GLC)
- RegEx (Express√µes regulares)
- Aut√¥matos finitos determin√≠sticos
- AST e grafos (Caso n√£o entenda muito, n√£o tem problema).

# O C√≥digo üñ•Ô∏è

Agora vamos come√ßar a entrar na parte mais interessante, como executar e como eu fiz esse projeto de forma resumida. Ent√£o vamos por partes:

### Executar

Antes de tudo, para conseguirmos executar o projeto:

- Rodamos o node.js e damos:

```
npm install
```

Eu usei uma ferramenta muito poderosa que constr√≥i o analisador l√©xico e sint√°tico baseado na nossa gram√°tica. A gram√°tica eu constru√≠ dentro do arquivo `pekLang.g4`. A ferramenta se chama `antlr4`.

Por√©m o _antlr4_ no node.js n√£o tem vers√µes muito est√°veis, ent√£o caso d√™ erro na hora de executar, precisamos fazer algumas coisas antes de executarmos o projeto:

- No arquivo `node_modules/antlr4/package.json` e devemos alterar o "main" somente para `"index.js"`

- No arquivo `node_modules/antlr4/RuleContext.js` devemos apagar o `.INVALID_ALT_NUMBER`, ou seja, o que estiver usando o INVALID_ALT_NUMBER como propriedade. Essa propriedade n√£o existe e dar√° erro.

- Voc√™ far√° a mesma coisa da etapa anterior no arquivo `node_modules/antlr4/tree/Trees.js`

- Com isso j√° podemos gerar o c√≥digo e rodarmos ele com o script `npm run compile`

## Como eu escrevi o c√≥digo ü§Ø

Bom, agora √© onde eu mais vou explicar sobre o projeto, pois √© a parte mais interessante mas que requer paci√™ncia.

Como podemos ver nas minha estrutura de pastas, o transpilador possui pilares importantes para ser feito:

- `Primeiro de tudo, o arquivo main.js, onde ele utiliza os analisadores l√©xicos e sint√°ticos do antlr4.`

```js
function main() {
  try {
    const input = antlr4.FileStream("../../source.pek");

    const chars = new antlr4.InputStream(input.strdata);
    const lexer = new pekLangLexer(chars);

    const tokens = new antlr4.CommonTokenStream(lexer);

    const parser = new pekLangParser(tokens);

    lexer.removeErrorListeners();
    lexer.addErrorListener(new MyErrorListener());
    parser.removeErrorListeners();
    parser.addErrorListener(new MyErrorListener());

    parser.prog();
  } catch (err) {
    console.log(err);
    fs.unlink("./CodeGenerated.js", (err) => {
      if (err) {
        console.log(" ");
      }
    });
  }
}
main();
```

Nem se preocupa com o c√≥digo, basicamente o analisador l√©xico analisa os chars do arquivo, o sint√°tico analisa os tokens (conjunto de chars), posteriormente o `parser.prog()`, que serve para executar o analisador.

Sendo o 'prog' o nome da minha regra gramatical principal.

```
prog  : 'GABRIEL' bloco 'PEKIM' (SemiColon)?
      {
      program.setVarTable(symbolTable);
      program.setCommands(stack.pop());
      generateCode();
      }
```

- `parser (analisador l√©xico, sint√°tico, etc.)` gerado pelo pr√≥prio antlr4 ao executar o script 'npm run antlr4'.

- `O grammar (gram√°tica), no arquivo pekLang.g4`: √â onde est√° toda minha gram√°tica e o que cada letra e palavra representa para o meu c√≥digo fonte, e baseado no grammar geramos os analisadores.

- `main.js`: Como ja disse, o arquivo principal, onde o analisador l√©xico e sint√°tico ser√° executado, analisando o arquivo apontado.

- `dataStructures`: √â a pasta onde est√° toda a minha estrutura de informa√ß√µes que precisam ser armazenadas durante a escrita do c√≥digo. Por exemplo: Cria√ß√µes de fun√ß√µes e vari√°veis.

```
  a = 5;
  fun hello(name){}

this.Variable -> name = 'a', type = number, value = 5

this.Function -> name = 'hello', params = [name]
```

O prop√≥sito disso t√° em n√£o criar fun√ß√µes repetidas, mesmo par√¢metros na mesma fun√ß√£o, etc. Realmente √© uma tabela, parecido com um banco de dados.

OBS: O arquivo `Stack.js` √© apenas uma forma mais simples de buscar elementos dentro de uma pilha.

- `AST (√Årvore sint√°tica abstrata)`

Como em qualquer linguagem, temos diversos tipos de comandos, e nessa pasta, eu peguei os principais, o suficiente para executar um fibonacci ou manipular as arrays. Talvez com uns bugs, mas todos n√≥s sabemos que _escrever c√≥digo √© escrever bugs._

### Como funciona a AST

Digamos que absolutamente tudo que temos √© um vetor enorme de comandos. Imagina dados armazenados em banco de dados ou em um arquivo JSON, onde podemos ter deriva√ß√µes em cima de deriva√ß√µes: `Posts, likes dos posts, coment√°rios dos posts, respostas dos coment√°rios, respostas das respostas, etc...`

Agora troque isso por comandos, alguns mais simples, outros que executam mais comandos ainda.

Exemplo:

```
if(condition){
  (cmd)+ -> 1 ou mais comandos
}
else {
  (cmd)+ -> 1 ou mais comandos
}

fun hello(){
  (cmd)* -> 0 ou mais comandos
}
```

e esses cmd podendo ser comando de atribui√ß√£o, condi√ß√£o, fun√ß√£o, execu√ß√£o de fun√ß√£o, leitura, escrita, retorno e acesso para manipula√ß√µes de arrays.

```
cmd   : readcmd
      | writecmd
      | attrcmd
      | decisioncmd
      | funcmd
      | funexec
      | returncmd
      | accesscmd
      ;
```

essa √© uma parte do grammar, e se analisarmos mais um pouco, podemos ver que alguns desses comandos, podem gerar 1 ou mais comandos.

Tudo que est√° em min√∫sculo no grammar s√£o `terminais`, podemos usar c√≥digo (nesse caso JavaScript) nos terminais. E os que est√£o em mai√∫sculo s√£o `n√£o-terminais`, simplesmente representando algum conjunto de caracteres.

Entrando um pouco mais no grammar, temos a regra gramatical que inicia o programa, a regra `prog`.

E como sou nada criativo, a minha gram√°tica deve come√ßar com "GABRIEL" e terminar com "PEKIM" com o ponto e v√≠rgula sendo opcional. No meio devemos ter a regra `bloco`.

A regra bloco √© a seguinte

```
bloco : {let currentThread = new Array();
           stack.push(currentThread);
      }
        (cmd)+
      ;
```

A regra cria uma primeira array 'currentThread', e essa array entra para pilha, a partir da√≠ podemos ter 1 ou mais comandos e o nosso c√≥digo-fonte come√ßa a surgir efeito. E se formos analisar posteriormente, cada comando instanciado ser√° inserido nessa pilha ou lista de comandos.

Imagine a pilha de comandos dessa forma:

```
stack = [] -> ap√≥s o primeiro stack.push -> stack = [[]]
```

Ou seja, s√£o vetores (current threads) dentro de um vetor principal `"stack"`.

Em casos que podemos ter uma sequ√™ncia de comandos dentro de um comando, como √© o exemplo do 'if else' que eu mostrei anteriormente. √â necess√°rio criarmos outra lista 'CurrentThread' e inserir na stack.

Exemplo:

```
AC
            { let currentThread = new Array();
            stack.push(currentThread);
            }
            (cmd)+
            FC
      {
            let trueList = new Array();
            trueList = stack.pop();
      }

      ('senao'
      AC
      {let currentThread = new Array();
      stack.push(currentThread);
            }
      (cmd)+
      FC
      {
      let falseList = new Array();
      falseList = stack.pop();


      resto do c√≥digo.....
```

Relaxa e vamos por partes:

1 - Na minha gram√°tica o 'AC' (Abre chaves) representa '{'

e o 'FC' (Fecha chaves) representa '}'

com os par√™nteses √© a mesma coisa

```
AP  : '('
    ;

FP  : ')'
    ;

AC : '{'
   ;

FC : '}'
   ;
```

Esse abrir de chaves e fechar de chaves √© a parte do 'if else':

if(condition)AC .... FC

senao AC .... FC

por quest√£o l√≥gica, nas linguagens de programa√ß√£o voc√™ tem uma sequ√™ncia de comando a seguir, podendo ser `1 ou mais comandos`.

Se esperamos 1 ou mais comandos ao abrir as chaves, ent√£o precisamos criar uma nova 'currentThread' e colocar dentro da stack. E a partir da√≠ a gente tem o '(cmd)+'.

Depois queremos essa lista de comandos (currentThread) para armazenar dentro de uma vari√°vel. Se for true, vai armazenar dentro da `trueList`, sen√£o, dentro da `falseList`.

Depois da sequ√™ncia de comandos, para armazenarmos precisamos simplesmente dar um `stack.pop()` para pegar a √∫ltima currentThread, que foi criada anteriormente.

#### Ok, mas como armazenamos os comandos dentro da currentThread??

Todo final de comando, deve ser instanciado contendo as informa√ß√µes precisas. Vamos seguir com o exemplo do comando citado:

```
let cmd = new DecisionCommand(exprDecision, trueList, falseList);
    stack.peek().push(cmd);
```

Criamos um objeto 'cmd' com as suas informa√ß√µes e demos um stack.peek() para ir no √∫ltimo elemento (currentThread) da stack.

E .push(cmd) para inserir o comando nessa currentThread.

E a classe `DecisionCommand` tem a seguinte constru√ß√£o

```js
class DecisionCommand extends AbstractCommand {
  constructor(condition, trueList, falseList) {
    super();
    this.condition = condition;
    this.trueList = trueList;
    this.falseList = falseList;
  }
...
```

### Gera√ß√£o de c√≥digo JavaScript (ou qualquer linguagem que voc√™ queira)

E para terminar o comando de decis√£o, temos que gerar um c√≥digo JavaScript, e a classe carrega o mesmo m√©todo que todos os comandos:

```js
 generateJavaScriptCode() {
    let str = "";
    str += `if (${this.condition}) {\n`;
    for (let cmd of this.trueList) {
      str += `${cmd.generateJavaScriptCode()}`;
    }
    str += "}\n";
    if (this.falseList.length > 0) {
      str += `else {\n`;
      for (let cmd of this.falseList) {
        str += `${cmd.generateJavaScriptCode()}`;
      }
    }
    str += "}\n";

    return str.toString();
  }
```

A falseList e trueList s√£o listas, portanto precisamos fazer um 'for let of' para retornar cada um desses cmd, e gerar c√≥digo javascript tamb√©m.

#### E como esses comandos realmente geram c√≥digo javascript?

Dentro da classe principal que deve conter esses comandos e depois gerar o c√≥digo com o m√©todo principal de gera√ß√£o `generateTarget()`:

```js
class PekProgram {
  constructor() {
    this.varTable = new PekSymbolTable();
  }

  generateTarget() {
    let str = "";
    str += `const readline = require("readline-sync");\n\n`;

    for (const command of this.commands) {
      str += `${command.generateJavaScriptCode()}\n`;
    }

    try {
      fs.writeFileSync("CodeGenerated.js", str);
    } catch (err) {
      console.error("Erro ao escrever o arquivo:", err);
    }
  }

  getCommands() {
    return this.commands;
  }

  setCommands(commands) {
    this.commands = commands;
  }
```

Pegamos cada commando gerado e iteramos na `str` e com o `fs.writeFileSync` geramos o arquivo contendo toda essa 'str'.

E √© na gram√°tica que atualizamos a lista de comandos na classe PekProgram, pegando toda a lista de comandos do c√≥digo fonte com um `stack.pop`.

```
prog  : 'GABRIEL' bloco 'PEKIM' (SemiColon)?
      {
      program.setVarTable(symbolTable);
      program.setCommands(stack.pop());
      generateCode();
      }
```

Lembra que inicialmente na regra 'bloco' criamos uma currentThread e inserimos na stack? √â justamente essa currentThread que ir√° para o setCommands.

Para relembrar...

```
bloco : {let currentThread = new Array();
           stack.push(currentThread);
      }
        (cmd)+
      ;
```

Depois de usar o setCommands, usamos a fun√ß√£o generateCode() que √© essa aqui:

```
function generateCode(){
      program.generateTarget();
}
```

#### Executa o m√©todo generateTarget() mostrado anteriormente.

√â claro que tem muito mais que eu posso explicar, mas brevemente esses s√£o os t√≥picos principais que achei melhor abordar.

## Existem outras formas de ser feito?

Definitivamente sim. As possibilidades s√£o muitas. E temos 2 op√ß√µes principais:

- Op√ß√£o A - Ao inv√©s de gerar um c√≥digo diretamente de uma linguagem, 'transpilando' ela. Podemos gerar um arquivo JSON, contendo as informa√ß√µes de cada comando.

Consequentemente criamos o nosso pr√≥prio interpretador desse JSON para executar cada comando de acordo com a sua informa√ß√£o (era justamente isso que voc√™ deveria fazer no rinha com a AST em JSON j√° feita por eles).

Por√©m, a gram√°tica que eu particularmente fiz, n√£o foi para esse caminho.

- Op√ß√£o B - Podemos gerar o c√≥digo de alguma linguagem de acordo com a AST de comandos constru√≠da, e obviamente utilizar o interpretador/compilador da pr√≥pria linguagem.

## Comandos dispon√≠veis

Eu deixei como exemplo a 'source.pek', por√©m aqui est√° alguns comandos que podemos utilizar no _PekimLanguage_:

- 'if else' (condicional);
- Atribui√ß√£o -> a = 5;
- Cria√ß√£o de fun√ß√£o -> fun name(){};
- Executar uma fun√ß√£o -> somente a fun√ß√£o;
- Ler uma vari√°vel (intera√ß√£o com terminal) -> 'ler(variable)';
- Escrever uma vari√°vel (print) -> 'escrever(id)';
- Retornar algo -> 'retornar';

##### Algumas manipula√ß√µes com a array

- Acessar array com indexa√ß√£o -> 'array[index]';
- Acessar o √∫ltimo elemento da array -> 'array.ultimo';
- Acessar o tamanho da array -> 'array.tamanho';
- Adicionar algum elemento na array -> 'array.adicionar(item)';
- Remover o √∫ltimo elemento da array -> 'array.remover()';

## Conclus√£o

Poderia mostrar muito mais do meu c√≥digo, por√©m seria um README enorme, ent√£o abordei os t√≥picos principais. Caso queira saber um pouco mais, leia do meu c√≥digo e veja playlists indicadas abaixo.

## Agradecimentos

Se voc√™ est√° at√© aqui, eu agrade√ßo por ter realmente se interessado. Espero que de alguma forma eu pude te ajudar.

E caso voc√™ queira aprender mais, eu utilizei algumas playlists necess√°rias para parte te√≥rica que eu recomendo:

<p align="left">
  <a href="https://youtube.com/playlist?list=PLqlIQgAFrQ14oDPZliY1-tyupYs0prBmW&si=KdnpRnWMj7pi-1gY" target= "_blank">üéì Teoria da linguagem - Hierarquia de Chomsky e aut√¥matos finitos. Com o professor Jos√© Rui.</a>
</p>

<p align="left">
  <a href="https://youtube.com/playlist?list=PLjcmNukBom6--0we1zrpoUE2GuRD-Me6W&si=2iNIExDnfWcjjxJZ" target= "_blank">üéì Compiladores - com o professor Isidro.</a>
</p>

"de gra√ßa recebestes, de gra√ßa dai."
